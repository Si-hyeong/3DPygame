import pygame
import math

class ShapeCanvas:
    def __init__(self, vertices, edges):
        self.screen_width = 800
        self.screen_height = 600
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
        pygame.display.set_caption("3D Shape Renderer")

        # Colors
        self.WHITE = (255, 255, 255)
        self.BLACK = (0, 0, 0)

        # Shape vertices and edges
        self.vertices = vertices
        self.edges = edges

        # Size
        self.scale = 100

        # Cam distance
        self.cam_distance = 5

        # Rotation angles
        self.angle_x = 0
        self.angle_y = 0

        self.clock = pygame.time.Clock()

    def project(self, point):
        """
        Project a 3D point to a 2D screen.
        x' = x / (z + d) * s
        d = distance from cam
        s = scale
        """
        scale = self.scale
        cam_distance = self.cam_distance
        x, y, z = point
        factor = scale / (z + cam_distance)
        x_proj = x * factor + self.screen_width // 2
        y_proj = -y * factor + self.screen_height // 2
        return int(x_proj), int(y_proj)

    def rotate(self, point, angle_x, angle_y):
        """
        Rotate a 3D point around the X and Y axes.
        Rotation matrix for x:
        [[1, 0, 0],
        [0, cos, -sin],
        [0, sin, cos]]

        For Y:
        [[cos, 0, sin],
        [0, 1, 0],
        [-sin, 0, cos]]
        """
        x, y, z = point

        # Rotate around X axis
        cos_x = math.cos(angle_x)
        sin_x = math.sin(angle_x)
        y, z = y * cos_x - z * sin_x, y * sin_x + z * cos_x

        # Rotate around Y axis
        cos_y = math.cos(angle_y)
        sin_y = math.sin(angle_y)
        x, z = x * cos_y + z * sin_y, -x * sin_y + z * cos_y

        return x, y, z

    def draw_shape(self):
        """
        Draw the shape on the screen.
        v' = Project(Rotate(v))
        v' = P.Ry(Úx).Rx(Úy).v
        Ú = theta
        """

        transformed_points = [self.rotate(v, self.angle_x, self.angle_y) for v in self.vertices]
        projected_points = [self.project(p) for p in transformed_points]

        for edge in self.edges:
            start, end = edge
            pygame.draw.line(self.screen, self.WHITE, projected_points[start], projected_points[end], 2)

    def handle_mouse_input(self):
        """Update rotation angles based on mouse movement."""
        mouse_dx, mouse_dy = pygame.mouse.get_rel()
        self.angle_x += math.radians(mouse_dy) * 0.2  # sensitivity for pitch
        self.angle_y += math.radians(mouse_dx) * 0.2  # sensitivity for yaw

    def game_loop(self):
        """Main game loop."""
        running = True

        # Enable mouse control
        pygame.mouse.set_visible(False)
        pygame.event.set_grab(True)

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

            self.screen.fill(self.BLACK)

            self.handle_mouse_input()
            self.draw_shape()
            pygame.display.flip()
            self.clock.tick(60)

        pygame.quit()


def generate_sphere(radius, resolution):
    """
    Generates vertices and edges for a sphere.
    """
    vertices = []
    edges = []
    for i in range(resolution):
        lat = math.pi * (-0.5 + i / (resolution - 1))
        for j in range(resolution):
            lon = 2 * math.pi * (j / resolution)
            x = radius * math.cos(lat) * math.cos(lon)
            y = radius * math.cos(lat) * math.sin(lon)
            z = radius * math.sin(lat)
            vertices.append([x, y, z])

    for i in range(resolution - 1):
        for j in range(resolution):
            edges.append((i * resolution + j, (i + 1) * resolution + j))
            edges.append((i * resolution + j, i * resolution + (j + 1) % resolution))
    return vertices, edges


def generate_cylinder(radius, height, resolution):
    """
    Generates vertices and edges for a cylinder.
    """
    vertices = []
    edges = []

    for i in range(resolution):
        angle = 2 * math.pi * (i / resolution)
        x = radius * math.cos(angle)
        y = radius * math.sin(angle)

        vertices.append([x, y, 0])  # bottom circle
        vertices.append([x, y, height])  # top circle

    for i in range(resolution):
        edges.append((i, (i + 1) % resolution))  # bottom circle
        edges.append((i + resolution, (i + 1) % resolution + resolution))  # top circle
        edges.append((i, i + resolution))  # vertical edges
    return vertices, edges


def generate_torus(outer_radius, inner_radius, resolution):
    """
    Generates vertices and edges for a torus.
    """
    vertices = []
    edges = []

    for i in range(resolution):
        theta = 2 * math.pi * i / resolution
        for j in range(resolution):
            phi = 2 * math.pi * j / resolution
            x = (outer_radius + inner_radius * math.cos(phi)) * math.cos(theta)
            y = (outer_radius + inner_radius * math.cos(phi)) * math.sin(theta)
            z = inner_radius * math.sin(phi)
            vertices.append([x, y, z])

    for i in range(resolution):
        for j in range(resolution):
            edges.append((i * resolution + j, i * resolution + (j + 1) % resolution))
            edges.append((i * resolution + j, ((i + 1) % resolution) * resolution + j))
    return vertices, edges

def generate_cone(radius, height, resolution):
    vertices = [[0, 0, height]]  # Cone apex
    edges = []

    for i in range(resolution):
        angle = 2 * math.pi * i / resolution
        x = radius * math.cos(angle)
        y = radius * math.sin(angle)
        vertices.append([x, y, 0])

    for i in range(1, resolution + 1):
        edges.append((0, i))  # Apex to base
        edges.append((i, (i % resolution) + 1))  # Base edges

    return vertices, edges

def get_shape_data(shape_name):
    """
    Returns vertices and edges for a given shape name.
    """
    shapes = {
        "cube": (
            [
                [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
            ],
            [
                (0, 1), (1, 2), (2, 3), (3, 0),
                (4, 5), (5, 6), (6, 7), (7, 4),
                (0, 4), (1, 5), (2, 6), (3, 7)
            ]
        ),
        "diamond": (
            [
                [0, 1, 0], [-1, 0, -1], [1, 0, -1], [1, 0, 1],
                [-1, 0, 1], [0, -1, 0]
            ],
            [
                (0, 1), (0, 2), (0, 3), (0, 4),
                (1, 2), (2, 3), (3, 4), (4, 1),
                (5, 1), (5, 2), (5, 3), (5, 4)
            ]
        ),
        "pyramid": (
            [
                [0, 1, 0], [-1, -1, -1], [1, -1, -1],
                [1, -1, 1], [-1, -1, 1]
            ],
            [
                (0, 1), (0, 2), (0, 3), (0, 4),
                (1, 2), (2, 3), (3, 4), (4, 1)
            ]
        ),
        "tetrahedron": (
            [
                [1, 1, 1], [-1, -1, 1], [-1, 1, -1], [1, -1, -1]
            ],
            [
                (0, 1), (1, 2), (2, 0),
                (0, 3), (1, 3), (2, 3)
            ]
        ),
        "sphere": generate_sphere(radius=1, resolution=12),
        "cylinder": generate_cylinder(radius=1, height=2, resolution=12),
        "torus": generate_torus(outer_radius=2, inner_radius=0.5, resolution=16),
        "cone": generate_cone(radius=1, height=2, resolution=12)
    }

    return shapes.get(shape_name)


if __name__ == "__main__":
    pygame.init()

    available_shapes = ["cube", "diamond", "pyramid", "tetrahedron", "sphere", "cylinder", "torus", "cone"]
    print(f"Available shapes: {', '.join(available_shapes)}")
    shape_name = input("Enter the shape to render: ").strip().lower()

    shape_data = get_shape_data(shape_name)
    if shape_data:
        vertices, edges = shape_data
        shape_canvas = ShapeCanvas(vertices, edges)
        shape_canvas.game_loop()
    else:
        print(f"Shape '{shape_name}' not recognized. Please restart and choose a valid shape.")
